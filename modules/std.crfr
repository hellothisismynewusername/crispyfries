/* ---- MATH ---- */

fn factorial32 inp i32 : i32 {
    do
        ~inp 1 i32 == if
            1 i32 -> ret
        else
            ~inp ~inp 1 i32 - fact * -> ret
        endif
        -1 i32 -> ret
    ;
}

fn factorial64 inp i64 : i64 {
    do
        ~inp 1 i64 == if
            1 i64 -> ret
        else
            ~inp ~inp 1 i64 - fact * -> ret
        endif
        -1 i64 -> ret
    ;
}

/* ---- STRINGS AND CHARS ---- */

fn itoc32 inp0 i32 : char {
    let outpu : char
    do
        ~inp0 0 i32 == if
            '0' -> outpu
        else
        endif
        ~inp0 1 i32 == if
            '1' -> outpu
        else
        endif
        ~inp0 2 i32 == if
            '2' -> outpu
        else
        endif
        ~inp0 3 i32 == if
            '3' -> outpu
        else
        endif
        ~inp0 4 i32 == if
            '4' -> outpu
        else
        endif
        ~inp0 5 i32 == if
            '5' -> outpu
        else
        endif
        ~inp0 6 i32 == if
            '6' -> outpu
        else
        endif
        ~inp0 7 i32 == if
            '7' -> outpu
        else
        endif
        ~inp0 8 i32 == if
            '8' -> outpu
        else
        endif
        ~inp0 9 i32 == if
            '9' -> outpu
        else
        endif

        outpu -> ret
    ;
}

fn itostr32 inp1 i32 : char^ {
    let var : i32
    let len : i32
    let b : bool
    let outp : char^
    do
        ~inp1 -> var
        0 i32 -> len
        true -> b
    ;

    /* getting len */
    b while
        do
            var 0 i32 == if
                false -> b
            else
                var 10 i32 / -> var
                len 1 i32 + -> len
            endif
        ;
    endwhile                                                                                                                                                                                                                                                                                                                                                          let var1 : i32                                                                                                                                                                   let b1 : bool
    let cntr : i32
    do
        len 1 i32 + malloc -> outp
        true -> b1
        ~inp1 -> var1
        len 1 i32 - -> cntr
    ;
    b1 while
        do
            var1 0 i32 == if
                0 i8 outp len @ <-
                false -> b1
            else
                var1 10 i32 rem itoc32
                outp cntr @ <-

                var1 10 i32 / -> var1
                cntr 1 i32 - -> cntr
            endif
        ;
    endwhile

    do outp -> ret;
}


fn strcat inp1 char^ inp2 char^ : char^ {
    let end_of_inp1 : i32
	let end_of_inp2 : i32

	/* finding end of ~inp1 */
	let not_reached : bool
	let cntr : i32
	do
		true -> not_reached
		0 i32 -> cntr
	;
	not_reached while
		do
			~inp1 cntr @ # 0 char == if
				false -> not_reached
			else
				cntr 1 i32 + -> cntr
			endif
		;
	endwhile
	do cntr -> end_of_inp1;


	/* finding end of ~inp2 */
	do
		true -> not_reached
		0 i32 -> cntr
	;
	not_reached while
		do
			~inp2 cntr @ # 0 char == if
				false -> not_reached
			else
				cntr 1 i32 + -> cntr
			endif
		;
	endwhile
	do cntr -> end_of_inp2;

    /* putting ~inp1 and ~inp2 into out */
	let out : char^
	let cntr1 : i32
	let cntr2 : i32
	let not_yet_reached_inp1_end : bool
	let not_yet_reached_inp2_end : bool
	do
		0 i32 -> cntr1 -> cntr2
		true -> not_yet_reached_inp1_end -> not_yet_reached_inp2_end

		end_of_inp1
		end_of_inp2 1 i32 +
		+
		malloc -> out
	;
	not_yet_reached_inp1_end while
		do
			~inp1 cntr1 @ # 0 char == if
				false -> not_yet_reached_inp1_end
			else
				~inp1 cntr1 @ # out cntr1 @ <-
				cntr1 1 i32 + -> cntr1
			endif
		;
	endwhile
	not_yet_reached_inp2_end while
		do
			~inp2 cntr2 @ # 0 char == if
				false -> not_yet_reached_inp2_end
			else
			endif
			~inp2 cntr2 @ # out cntr2 end_of_inp1 + @ <-
            cntr2 1 i32 + -> cntr2
		;
	endwhile

	do out -> ret;
}